{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar react_1 = require(\"react\");\nvar attributes_to_props_1 = __importDefault(require(\"./attributes-to-props\"));\nvar utilities_1 = require(\"./utilities\");\nvar React = {\n  cloneElement: react_1.cloneElement,\n  createElement: react_1.createElement,\n  isValidElement: react_1.isValidElement\n};\n/**\n * Converts DOM nodes to JSX element(s).\n *\n * @param nodes - DOM nodes.\n * @param options - Options.\n * @returns - String or JSX element(s).\n */\nfunction domToReact(nodes, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var reactElements = [];\n  var hasReplace = typeof options.replace === 'function';\n  var transform = options.transform || utilities_1.returnFirstArg;\n  var _a = options.library || React,\n    cloneElement = _a.cloneElement,\n    createElement = _a.createElement,\n    isValidElement = _a.isValidElement;\n  var nodesLength = nodes.length;\n  for (var index = 0; index < nodesLength; index++) {\n    var node = nodes[index];\n    // replace with custom React element (if present)\n    if (hasReplace) {\n      var replaceElement = options.replace(node, index);\n      if (isValidElement(replaceElement)) {\n        // set \"key\" prop for sibling elements\n        // https://react.dev/learn/rendering-lists#rules-of-keys\n        if (nodesLength > 1) {\n          replaceElement = cloneElement(replaceElement, {\n            key: replaceElement.key || index\n          });\n        }\n        reactElements.push(transform(replaceElement, node, index));\n        continue;\n      }\n    }\n    if (node.type === 'text') {\n      var isWhitespace = !node.data.trim().length;\n      // We have a whitespace node that can't be nested in its parent\n      // so skip it\n      if (isWhitespace && node.parent && !(0, utilities_1.canTextBeChildOfNode)(node.parent)) {\n        continue;\n      }\n      // Trim is enabled and we have a whitespace node\n      // so skip it\n      if (options.trim && isWhitespace) {\n        continue;\n      }\n      // We have a text node that's not whitespace and it can be nested\n      // in its parent so add it to the results\n      reactElements.push(transform(node.data, node, index));\n      continue;\n    }\n    var element = node;\n    var props = {};\n    if (skipAttributesToProps(element)) {\n      (0, utilities_1.setStyleProp)(element.attribs.style, element.attribs);\n      props = element.attribs;\n    } else if (element.attribs) {\n      props = (0, attributes_to_props_1.default)(element.attribs, element.name);\n    }\n    var children = void 0;\n    switch (node.type) {\n      case 'script':\n      case 'style':\n        // prevent text in <script> or <style> from being escaped\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\n        if (node.children[0]) {\n          props.dangerouslySetInnerHTML = {\n            __html: node.children[0].data\n          };\n        }\n        break;\n      case 'tag':\n        // setting textarea value in children is an antipattern in React\n        // https://react.dev/reference/react-dom/components/textarea#caveats\n        if (node.name === 'textarea' && node.children[0]) {\n          props.defaultValue = node.children[0].data;\n        } else if (node.children && node.children.length) {\n          // continue recursion of creating React elements (if applicable)\n          children = domToReact(node.children, options);\n        }\n        break;\n      // skip all other cases (e.g., comment)\n      default:\n        continue;\n    }\n    // set \"key\" prop for sibling elements\n    // https://react.dev/learn/rendering-lists#rules-of-keys\n    if (nodesLength > 1) {\n      props.key = index;\n    }\n    reactElements.push(transform(createElement(node.name, props, children), node, index));\n  }\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\n}\nexports.default = domToReact;\n/**\n * Determines whether DOM element attributes should be transformed to props.\n * Web Components should not have their attributes transformed except for `style`.\n *\n * @param node - Element node.\n * @returns - Whether the node attributes should be converted to props.\n */\nfunction skipAttributesToProps(node) {\n  return utilities_1.PRESERVE_CUSTOM_ATTRIBUTES && node.type === 'tag' && (0, utilities_1.isCustomComponent)(node.name, node.attribs);\n}","map":{"version":3,"mappings":"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","names":["React","cloneElement","createElement","isValidElement","domToReact","nodes","options","reactElements","hasReplace","replace","transform","utilities_1","library","nodesLength","length","index","node","replaceElement","key","push","type","isWhitespace","data","trim","parent","element","props","skipAttributesToProps","attribs","style","name","children","dangerouslySetInnerHTML","__html","defaultValue","exports"],"sources":["/Users/suyashgupta/Downloads/tour-management-mid-eval/frontend/node_modules/html-react-parser/src/dom-to-react.ts"],"sourcesContent":["import { cloneElement, createElement, isValidElement } from 'react';\nimport type { JSX } from 'react';\nimport type { Element, DOMNode, Text } from 'html-dom-parser';\n\nimport attributesToProps from './attributes-to-props';\nimport type { Props } from './attributes-to-props';\nimport {\n  PRESERVE_CUSTOM_ATTRIBUTES,\n  canTextBeChildOfNode,\n  isCustomComponent,\n  returnFirstArg,\n  setStyleProp,\n} from './utilities';\n\nimport type { HTMLReactParserOptions } from './types';\n\nconst React = {\n  cloneElement,\n  createElement,\n  isValidElement,\n} as const;\n\n/**\n * Converts DOM nodes to JSX element(s).\n *\n * @param nodes - DOM nodes.\n * @param options - Options.\n * @returns - String or JSX element(s).\n */\nexport default function domToReact(\n  nodes: DOMNode[],\n  options: HTMLReactParserOptions = {},\n): string | JSX.Element | JSX.Element[] {\n  const reactElements = [];\n\n  const hasReplace = typeof options.replace === 'function';\n  const transform = options.transform || returnFirstArg;\n  const { cloneElement, createElement, isValidElement } =\n    options.library || React;\n\n  const nodesLength = nodes.length;\n\n  for (let index = 0; index < nodesLength; index++) {\n    const node = nodes[index];\n\n    // replace with custom React element (if present)\n    if (hasReplace) {\n      let replaceElement = options.replace!(node, index) as JSX.Element;\n\n      if (isValidElement(replaceElement)) {\n        // set \"key\" prop for sibling elements\n        // https://react.dev/learn/rendering-lists#rules-of-keys\n        if (nodesLength > 1) {\n          replaceElement = cloneElement(replaceElement, {\n            key: replaceElement.key || index,\n          });\n        }\n\n        reactElements.push(transform(replaceElement, node, index));\n        continue;\n      }\n    }\n\n    if (node.type === 'text') {\n      const isWhitespace = !node.data.trim().length;\n\n      // We have a whitespace node that can't be nested in its parent\n      // so skip it\n      if (\n        isWhitespace &&\n        node.parent &&\n        !canTextBeChildOfNode(node.parent as Element)\n      ) {\n        continue;\n      }\n\n      // Trim is enabled and we have a whitespace node\n      // so skip it\n      if (options.trim && isWhitespace) {\n        continue;\n      }\n\n      // We have a text node that's not whitespace and it can be nested\n      // in its parent so add it to the results\n      reactElements.push(transform(node.data, node, index));\n      continue;\n    }\n\n    const element = node as Element;\n    let props: Props = {};\n\n    if (skipAttributesToProps(element)) {\n      setStyleProp(element.attribs.style, element.attribs);\n      props = element.attribs;\n    } else if (element.attribs) {\n      props = attributesToProps(element.attribs, element.name);\n    }\n\n    let children: ReturnType<typeof domToReact> | undefined;\n\n    switch (node.type) {\n      case 'script':\n      case 'style':\n        // prevent text in <script> or <style> from being escaped\n        // https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html\n        if (node.children[0]) {\n          props.dangerouslySetInnerHTML = {\n            __html: (node.children[0] as Text).data,\n          };\n        }\n        break;\n\n      case 'tag':\n        // setting textarea value in children is an antipattern in React\n        // https://react.dev/reference/react-dom/components/textarea#caveats\n        if (node.name === 'textarea' && node.children[0]) {\n          props.defaultValue = (node.children[0] as Text).data;\n        } else if (node.children && node.children.length) {\n          // continue recursion of creating React elements (if applicable)\n          children = domToReact(node.children as Text[], options);\n        }\n        break;\n\n      // skip all other cases (e.g., comment)\n      default:\n        continue;\n    }\n\n    // set \"key\" prop for sibling elements\n    // https://react.dev/learn/rendering-lists#rules-of-keys\n    if (nodesLength > 1) {\n      props.key = index;\n    }\n\n    reactElements.push(\n      transform(createElement(node.name, props, children), node, index),\n    );\n  }\n\n  return reactElements.length === 1 ? reactElements[0] : reactElements;\n}\n\n/**\n * Determines whether DOM element attributes should be transformed to props.\n * Web Components should not have their attributes transformed except for `style`.\n *\n * @param node - Element node.\n * @returns - Whether the node attributes should be converted to props.\n */\nfunction skipAttributesToProps(node: Element): boolean {\n  return (\n    PRESERVE_CUSTOM_ATTRIBUTES &&\n    node.type === 'tag' &&\n    isCustomComponent(node.name, node.attribs)\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}